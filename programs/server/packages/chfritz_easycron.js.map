{"version":3,"sources":["meteor://ðŸ’»app/packages/chfritz_easycron/cron.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/chfritz_easycron.js","sourcesContent":["\nvar units = [{unit: \"minute\",\n              set: \"setMinutes\",\n              get: \"getMinutes\",\n              ms: 60 * 1000,\n              max: 60},\n             {unit: \"hour\",\n              set: \"setHours\",\n              get: \"getHours\",\n              ms: 60 * 60 * 1000,\n              max: 24},\n             {unit: \"day\",\n              set: \"setDate\",\n              get: \"getDate\",\n              ms: 24 * 60 * 60 * 1000},\n             {set: \"setMonth\",\n              get: \"getMonth\"}\n            ];\n\n/** given the schedule, determine the next occurence after now */\nfunction getNext(schedule) {\n\n    function isDef(x) {\n        return (typeof(x) != 'undefined');\n    }\n\n    var now = new Date();\n    var next = new Date();\n    // default: next minute\n    next.setSeconds(0);\n    _.each(units, function(value) {\n        if (value.unit) {\n            if (isDef(schedule[value.unit])) {\n                next[value.set](schedule[value.unit]);\n            }\n        }\n    });\n\n    // Step 2: push it into the future\n    var diff = next - now;\n    if (diff <= 0) {\n        // go incrementally from minutes to months. if they are\n        // flexible, use them to reach the future, or set them to zero\n        _.each(units, function(value, index, list) {\n            if (next <= now\n                && (!value.unit \n                    || !isDef(schedule[value.unit]))) {\n\n                if (now - next > value.ms * value.max) {\n                    // the difference is greater than what this unit\n                    // can bridge: set to zero and kick the bucket\n                    // down the road\n                    next[value.set](0);\n                } else {\n                    next[value.set](next[value.get]()+1);\n                }\n            }\n        });\n\n    }\n\n    // Step 3: pull back as close as possible\n    _.each(units, function(value) {\n        if (value.unit) {\n            if (!isDef(schedule[value.unit])\n                && Math.abs(now - next) > value.ms) {\n                next[value.set](0);\n            }\n        }\n    });\n\n\n    return next;\n}\n\n/** recursive function for scheduling the timeouts */\nfunction sched(fn, schedule) {\n    var next = getNext(schedule);\n\n    // assert: next is now the next desired occurrence\n    // console.log(\"setting timer for: \", next);\n    var diff = next - new Date();\n\n    // We need to make sure not to overrun the 32-bit buffer storing\n    // the timeout:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window.setTimeout\n    if (diff < 2147483647) {\n        // the next time is close enough: schedule it\n        Meteor.setTimeout(\n            function() {\n                fn();\n                sched(fn, schedule);\n            }, \n            diff\n        );\n    } else {\n        // the next occurrence is too far out: check back in 14 days\n        Meteor.setTimeout(\n            function() {\n                sched(fn, schedule);\n            }, \n            1209600000\n            // 3000\n        );\n    }\n}\n\nCron = function(fn, schedule) {\n    sched(fn, schedule);\n};\n"]}